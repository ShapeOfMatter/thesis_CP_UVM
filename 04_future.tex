\chapter{Beyond \MultiChor}
\label{sec:future}

We believe \MultiChor to be the best off-the-shelf system presently available for any real-world applications of CP.
We are also confident that \HLSCentral and the associated theorems demonstrate the theoretical soundness of the conclaves-\&-MLVs
CP paradigm.
That said, it is unsatisfying that the syntactic structures of these two systems are so different from each other.
Furthermore, it is not clear that these systems as they stand are good foundations for the development of more advanced CP techniques,
nor is it clear that the current design of the \MultiChor as a software library is ideal for real-world engineering.
In \Cref{sec:usability} we discuss some known usability problems with the existing \MultiChor implementation
(as distinct from theoretical limitations).
In \Cref{sec:future-implementation} we describe a fork of \MultiChor, a research prototype with some theoretical implications that will affect
the design of future \MultiChor versions.

\section{User challenges in \MultiChor}
\label{sec:usability}

Industry use of CP concepts remains nascent,
but enough embedded or semi-embedded implementations now exist or are in development that prospective users
will need to actively choose between them.
Just within the Haskell ecosystem, it's possible that an engineer might accept the excess communication necessitated by \HasChor's
KoC strategy in order to avoid the conceptual (and textual) overhead of census tracking.
Indeed, although we know of no "in the wild" use of \MultiChor,
anecdotal reports from academic peers who have attempted to use the library suggest it would benefit from substantial further cosmetic work,
and may need theoretical breakthroughs to appeal to non-academic developers.

\subsection{General Feedback}
\label{sec:usability-sources}
A few people that we know of (besides ourselves) have actually attempted to write programs using \MultiChor.
A couple of our fellow students accepted our invitation to do try a small programming exercise modeled after a job-interview exercise.
The exercise itself is described in \Cref{sec:usability-exercise}.
These sessions were not structured as a controlled usability study;
volunteers were invited to ask for help with any part of the exercise they wished.
Nonetheless, none of the volunteers were able to implement the described protocol,
which had been designed both for brevity and to exactly fit \MultiChor's capabilities.
This was our most detailed source of feedback.

While our own efforts to asses \MultiChor's usability were illuminating and negative,
we also received feedback on the software artifact~\cite{ourArtifact} submitted alongside~\cite{batesenclaves}.

One point of feedback has been practically unanimous:
\MultiChor's existing documentation is insufficient.
Relying on type signatures to communicate behavior presupposes familiarity with \MultiChor's types,
and the textual documentation, however systematic, is not suitable for bootstrapping a new user's understanding.
The example choreographies included in the \MultiChor repository are not presented as a form of documentation, 
and therefor do not serve that purpose.
Regarding specific directions for future documentation,
the documentation of \MultiChor's API should have relevant examples built into it,
and the entry-point of the documentation (the \inlinecode[bash]{README} file) should be structured as a tutorial.
Furthermore, the module structure of the repository should be refactored to reflect how the API will be \emph{used},
instead of how it was \emph{engineered}.

\subsection{The proof-witnesses system}

A major hurdle to writing correct choreographies with \MultiChor is constructing and managing the proof-witness arguments.
Regardless of whether or not the system is overly-complicated
(to quote both the volunteers from the usability exercise:
\emph{"It's kinda complicated."})
the cognitive load of using the proof-witness system is \emph{additional} to, and mostly \emph{perpendicular} to,
the complexity of writing the actual choreography.
In other words,
a user must consider both how to represent a choreographic behavior using \MultiChor's operators
and how to prove that the relevant parties have the relevant memberships,
and because the proofs serve double-duty as identifiers, the user must think about those two problems simultaneously.

It's not unusual for a Haskell library to have a steep learning curve,
but we observe that the proof-witness system is a real bottleneck to use of \MultiChor,
so it would be worth improving.
Furthermore, the existing system is lacking certain capabilities one would expect,
such as the ability to talk about set unions, intersections, and differences.
There are two plausible directions for improvident;
neither of them are perfectly clear at this time:
\begin{enumerate}
	\item Remove the witnesses altogether in favor of constraint programming.
		(\inlinecode{Proxy} objects would still be necessary in some cases, but contain no complexity.)
		As explained in \Cref{sec:membership}, normal \inlinecode{class}es will not suffice,
		but quantified constraints~\cite{bottu2017} are not yet ruled out.
		Specifically, type-level programming with GHC's \inlinecode{QuantifiedConstraints} extension
		will be able to automatically infer sufficient subset relations,
		\emph{if} a satisfactory representation of membership constraints can be expressed.
	\item Externalize the proof-witness system.
		Several experimental systems exist for reasoning about type-level sets in Haskell,
		including \inlinecode{gdp}~\cite{gdp_hackage} and \inlinecode{type-level-sets}~\cite{tls_hackage}.
		If truly no off-the-self library exists that's suitable for the challenges of \MultiChor,
		then \MultiChor's solution should be separated as a stand-alone library.
		Regardless of where an external library came from, its externalness would facilitate code-reuse 
		and clarify a separation of concerns.
\end{enumerate}

\subsection{"Compute this" operators}

\MultiChor offers three "basic" operators for embedding non-choreographic computation in a choreography:
\inlinecode{locally}, \inlinecode{congruently}, and \inlinecode{parallel}.
Each of these is derived from more primitive forms, and each has further derived forms
(\eg \inlinecode{_locally_}, \inlinecode{purely}).
Choosing the best of these options for any given task is worse than a needle-in-haystack problem,
because multiple of them may actually work,
and because some may appear to work for the immediate task while causing problems later in the program.

In \Cref{sec:future-implementation} we will see a possibility for removing some of this complexity.
Regardless of whether the development of \MultiChor actually goes in that direction,
the cost (as measured in end-user boilerplate) of removing (or not exporting) most of these functions
would probably be worth the benefit of simplifying the choices they present to end-users.

\subsection{Clarity over flexibility}

To send a value in \MultiChor one must (in addition to specifying the recipients)
provide a MLV and prove that the sender both owns the value and is present in the census.
This can be quite repetitive.
To minimise boiler-plate, the surface API of \MultiChor uses a class \inlinecode{CanSend}
so that the broad- and multi-cast functions can take the proof arguments in different formats.
In keeping with the above theme of reducing the space of options users must navigate,
\inlinecode{CanSend} should be removed and the functions should each have a single, general-purpose, signature.

More broadly, we suggest abandoning the existing implementation-focused module structure
that separates operators across three modules ("core", "surface", and "batteries")
in favor of exporting a single surface-level API.
We expect that users will build predictable helper functions on top of this,
but trying to preempt their efforts doesn't seem to have helped prospective users.

\section{"Mini"-Chor}
\label{sec:future-implementation}
It is natural to ask why \MultiChor has a "core" API distinct from the ergonomic API afforded to end-users.
This design pattern makes reasoning about \MultiChor's implementation easier;
whether there are any performance implications has not been explored\footnote{
  The need for methods for comparing the performance of CP systems was acknowledged by the community
  of CP researchers attending PLDI24.
}.
In the coming months, we would like to push the simplicity of the core API even further:
\begin{enumerate}
  \item The use of a freer monad system is not actually necessary.
        It facilitates implementation, but it's also an additional "moving part" that can be removed
        without affecting the system's behavior.
\item As mentioned in \Cref{sec:multichor}, the functions \inlinecode{flatten} and \inlinecode{othersForget}
        could be removed from the core API and replaced with derived monadic functions.
        This would be a step backwards for the ergonomics of \MultiChor,
        so we do not advocate making such a change to the version published on Hackage.
  \item Replacing the core operation \inlinecode{congruently'} with \inlinecode{naked}
        (a monadic operator that unwraps an MLV known to the entire census)
        may degrade ergonomics.
        On the other hand, it would also allow simplification of \inlinecode{locally'}
        by obviating the \inlinecode{Unwrap} argument;
        \ie \inlinecode{locally'}'s argument would no longer be a function at all!
  \item Having made the above changes, the only remaining place where \inlinecode{Located} values would get unwrapped
        would be \inlinecode{naked}.
        We would be able to remove the underlying \inlinecode{Choreo} constructor for \inlinecode{naked}
        and change the implementation of \inlinecode{Located} to be a \inlinecode{newtype} wrapper for
        a census-polymorphic choreography yielding the target value.
        In other words, \inlinecode{naked} would be the field accessor function for \inlinecode{Located}.
\end{enumerate}

By making these changes, which we expect to preserve in a clearly labeled fork of \MultiChor,
we will facilitate subsequent theoretical work on CP.
In particular, the reduced API would make a good target for a more fully-featured formal model.

\bibliographystyle{chicago}
\bibliography{refs}
