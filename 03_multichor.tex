\chapter{Real World Choreographic Programming}
\chaptermark{\MultiChor?} %this is the chapter heading that will show on subsequent pages
\label{sec:multichor}


\section{Introduction}
In this chapter we demonstrate the practicality of enclaves-\&-MLVs choreographic programming
by presenting our implementation:
the \MultiChor Haskell library.
\MultiChor is a "just a library" CP system in the style of HasChor.
We adopt HasChor's freer-monads and handlers design pattern,
and embed the key aspects of \HLSCentral's type system as type-level constraints with a bespoke proof-witness system.

A key innovation of \HLSCentral is that KoC is enforced entirely
by type-level management of the census.
By representing the census as a type-level variable in Haskell,
\MultiChor enables polymorphism over both the size and membership of the census,
a feature not considered in the construction of \HLSCentral.
All Haskell typing happens statically, and \MultiChor's EPP happens at runtime (like HasChor's).
This means that, like other cases of polymorphism in Haskell, location polymorphism in \MultiChor must be resolved statically.

A few other desiderata motivate our implementation:
\begin{enumerate}
    \item It should be possible to broadcast, \ie to multicast a value to the entire census,
          and to use values known to the entire census as normal (un-located) values of their type.
    \item It should be possible to know from an appropriately-written choreography's type that some
          certain party or parties are not involved, are not in its census.
          Users should be able to embed such "enclave" choreographies inside choreographies with larger,
          possibly polymorphic, censuses.
    \item The type system should be able to reason about parties'
          membership in a census or ownership-set
          with normal subset reasoning.
\end{enumerate}
The choreography in Figure~\ref{fig:card-game} showcases the above points.
The census of the whole program appears in the type
and does not specify who the players are.
The \inlinecode{enclaveTo} on line~18
embeds a choreography whose census is exactly the monomorphic \inlinecode{"dealer"}
and a polymorphic \inlinecode{player} (\#2).
The helper-function \inlinecode{broadcast} on line 19 functions as described in \#1.
Many examples of \#3 are automated or hidden in \MultiChor,
but on line~19 the function \inlinecode{inSuper} is applied to
\inlinecode{players :: Subset players ("dealer" : players)}
and \inlinecode{player :: Member player players}
to attest that \inlinecode{player} is present in the census.

\begin{figure*}[tbhp]
    \begin{mdframed}
    \inputminted[xleftmargin=10pt,linenos,fontsize=\scriptsize]{haskell}{figures/census-poly-example.hs.txt}
    \caption{A card game expressed as a choreography written in \MultiChor.
             This choreography is polymorphic over the number and identity of the players,
             but the party named \inlinecode{"dealer"} is an explicit member.
             The inner monad \inlinecode{CLI} that all parties have access to is a simple freer monad
             that can be handled to IO operations, or as \inlinecode{State} for testing purposes.
             The \inlinecode{newtype Card} encapsulates the modulo operation in its
             \inlinecode{Num} instance.}
    \label{fig:card-game}
    %\Description{Thirty lines of haskell code describing a choreography called "game".}
    \end{mdframed}
\end{figure*}


\section{Censuses, Enclaves, and MLVs in Haskell}
\label{sec:implementation}

\MultiChor uses the same free-monad approach as \HasChor~\cite{shen-haschor} to implement choreographic programming, EPP,
and the final interpretation to a real communication mechanism.
Also like \HasChor, \MultiChor's \inlinecode{Choreo} monad is parameterised by a \emph{local monad} in which parties' local computations can be expressed.
A \MultiChor type \inlinecode{Located ps t} is a multiply-located \inlinecode{t} owned by the parties \inlinecode{ps}.
It is possible to write \MultiChor functions that look and work like each of \HasChor's three primitive operators,
but the derived API in which users write \MultiChor choreographies contains a clear analog of only one of \HasChor's primitives.
Haskell's monadic-\inlinecode{do} notation and purity-oriented type system make \MultiChor code concise and safe
(in the sense that users are unlikely to accidentally invalidate important invariants).

As explained in Section~\ref{sec:formalism},
our KoC strategy requires that the correctness (well-typed-ness) of choreographies be judged in the context of a census.
\MultiChor adds the census as a type parameter of the \inlinecode{Choreo} monad.
Its kind is \inlinecode{[Symbol]},
which is to say that the census is a type-level list of parties and parties are type-level strings.
\inlinecode{Choreo} is \emph{not} an \emph{indexed} monad (that is, executing a monadic operation doesn't change the census),
but monadic operations can take choreographies with smaller censuses as arguments.

\begin{figure*}[tbhp]
  \begin{mdframed}
    \inputminted[xleftmargin=10pt,linenos,fontsize=\scriptsize]{haskell}{figures/operators-multichor.hs.txt}
    \caption{
        The fundamental operators for writing expressions in \MultiChor's \inlinecode{Choreo} monad.
        Of these four operators, \inlinecode{enclave} is the only one users will usually call directly;
        the other three can combine with each other (and with \inlinecode{enclave}) to make more user-friendly alternatives.
    }
    \label{fig:operators-multichor}
    %\Description{Four type signatures for Haskell functions using the MultiChor library.}
  \end{mdframed}
\end{figure*}

The fundamental operations of \MultiChor's \inlinecode{Choreo} monad are
\inlinecode{enclave}, \inlinecode{broadcast'}, \inlinecode{locally'}, and \inlinecode{congruently'}.
Their type signatures are given in \Cref{fig:operators-multichor}.
Like in \HasChor, these are free-monad constructors; their behavior is implemented in interpreters
that carry out EPP or implement a centralized semantics.
Three of them have their names "primed" because the un-primed versions of these names are reserved for more ergonomic derived functions.
For example, \inlinecode{locally'} takes a single argument, a computation in the local monad, and requires that the census contains
\emph{a single party}, who will execute that computation.
The un-primed \inlinecode{locally} takes an additional argument that identifies a single party from a larger census;
it uses \inlinecode{enclave} to correctly call \inlinecode{locally'}.
\inlinecode{broadcast} shares a \inlinecode{Located} value with the entire census so the unwrapped value can be used;
by combining this with \inlinecode{enclave} we can implement point-to-point or multicast communication.
From the perspective of a centralized semantics, \inlinecode{enclave} doesn't do anything at all besides run
the sub-choreography,
but EPP to a party \emph{not} in the sub-census skips the sub-choreography and just returns \inlinecode{Empty}.

\inlinecode{congruently} lets us leverage MLVs to concisely write actively-replicated computations.
In contrast to \inlinecode{locally}, the computation is performed by multiple parties
and the result is multiply-located across all of them.\footnote{
    The entire census participates in the primed version, and its result is returned naked.
    The behavior of \inlinecode{enclave} and the more fundamental rules of monadic programming
    ensure the un-primed \inlinecode{congruently} behaves correctly.
}
For the execution of these actively-replicated computations to correctly return an MLV,
all the parties must be guaranteed to be doing a pure computation on the same data.
Haskell makes it easy to enforce such a guarantee to a practical (but not unbreakable) extent.
This is why \inlinecode{congruently} does not grant access to the local monad \inlinecode{m}.
It also requires that the computation not have access to the specific identity of the computing party,
unlike \inlinecode{locally} and the similar-looking function \inlinecode{parallel} mentioned in \Cref{sec:census-poly}.
Weakening (or subverting) these restrictions would allow a user to violate \MultiChor's invariant that MLVs (\inlinecode{Located} values)
have the same value across all their owners.

It is critical to the safety of \MultiChor that the projection of a choreography to any given party will not use
any other party's \inlinecode{Located} values.
We use the same basic strategy for this as \HasChor:
\inlinecode{Located}'s constructors, \inlinecode{Wrap} and \inlinecode{Empty}, are hidden inside the core module
and afforded only by dependency injection to \inlinecode{locally} and \inlinecode{congruently}.
The specific "unwrapper" functions afforded to \inlinecode{locally} and \inlinecode{congruently}
are known to user code only by their type signatures, which have respective aliases \inlinecode{Unwrap} and \inlinecode{Unwraps}.
\inlinecode{Located}'s constructors are also used by two less-critical functions, \inlinecode{flatten} and \inlinecode{othersForget}.
These are needed for shrinking ownership sets or un-nesting \inlinecode{Located} values;
they could be written using \inlinecode{congruently},
but by implementing them in the core module where they can pattern-match \inlinecode{Located} values we are able to make them not-monadic,
and so more convenient.


\section{Membership Constraints}
\label{sec:membership}

It is not trivial for Haskell's type-checker (a component of GHC, the compiler) to judge if
a particular participant owns a multiply-located value or is present in a particular census
when the party or the set are polymorphic.
Declaring membership and subset relations as class constraints can work in some situations,
but this strategy has serious limitations which we find unacceptable.
For example, a rule as obvious as
$(p \in ps_1 \land ps1 \subseteq ps_2) \to p \in ps_2$,
represented in Haskell as
\inlinecode{instance ( IsMember p ps1, IsSubset ps1 ps2) => IsMember p ps2},
would be impossible to use because the compiler has no way of guessing which set \inlinecode{ps1}
it should be checking \inlinecode{p}'s membership in
(and even if it could \emph{guess}, it wouldn't backtrack and try a different guess if its first try didn't work).

To work around such limitations, \MultiChor uses a strategy of \emph{proof witnesses}
like those described by \cite{noonanGDP}.
These are vacuous runtime values with specially crafted types,
such that the existence of a value of the given type guarantees the truth of some logical assertion.
We do not actually use the \inlinecode{gdp}\footnote{
    "Ghosts of Departed Proofs"~\cite{gdp_hackage}
} package; we found that writing our own purpose-specific system had a few advantages.
First, we were able to write everything we needed without hand-waving any foundations as \inlinecode{axiom}s.
Second, pattern matching against the constructors of \inlinecode{Member l ls} suffices to convince GHC that \inlinecode{ls} is not empty,
which is sometimes useful.
Finally, the implicit paradigm of "memberships as indices \& subsets as functions" was qualitatively easier to work with
when we were building the census-polymorphism tools described in Section~\ref{sec:census-poly}.

In \MultiChor, locations are identified by type-level strings, uninhabited types with "kind" \inlinecode{Symbol}.
A values of type \inlinecode{Member p ps} can be used both
as proof that \inlinecode{p} is eligible to take some action (because of their membership in \inlinecode{ps})
and as a term-level identifier for the party \inlinecode{p}.
It's actual form will be that of an index in the type-level list \inlinecode{ps} at which \inlinecode{p} appears.
Subset relations are expressed and used similarly.
A value of type \inlinecode{Subset ps qs} has the underlying form of a function
from \inlinecode{Member p ps} to \inlinecode{Member p qs},
\emph{universally quantified over \inlinecode{p}}.
Because these logical structures can be built from scratch inside Haskell's type system,
all of the machinery we use to do so can safely be exposed to end-users so that they can write their own proofs, as needed, inside choreographies.
In practice however, they will usually use higher-level operators.
For example, the pattern \inlinecode{p @@ nobody}, read as \emph{"\inlinecode{p} and nobody else"},
makes a \inlinecode{Subset '[p] ps} out of a \inlinecode{Member p ps}.


\section{Census Polymorphism}
\label{sec:census-poly}

So far, the example choreographies we have discussed have had fixed numbers of participants.
In all prior CP systems this has been a syntactic constraint:
even systems that allow polymorphism over the identities of participants require the participants' "roles" to be explicitly defined in-context.
This is a serious limitation for writing choreographic software;
modern concurrent systems often use dozens to thousands of participants
and are defined parametrically over their number of participants~\cite{bigConcurrent1, corrigan2017prio, bigConcurrent3, bigConcurrent4, dprio2023}.
We assert that such parametric protocol declarations are a required feature for CP to find mainstream use;
our systems provide it in the form of \emph{census polymorphism}.

By "census polymorphism", we mean that a choreographic expression is polymorphic over its census type-variable,
including not just the specific identities listed but also the quantity.\footnote{
    In principle, one can split hairs between census polymorphism and similar polymorphism over other sets of parties, \eg ownership sets.
    We have not found such distinctions to be useful for describing system capabilities,
    but they can be relevant when talking about the type of a given expression.
}
Naïvely, this is trivial; any \MultiChor expression can easily be written with a type variable as its census
and the relevant parties (whose exact identities can also be polymorphic) can be guaranteed to be present by taking
membership proofs as arguments.
However, this approach has a limitation: Since the number of type variables of a choreography must be fixed
and there is no way to \emph{explicitly list} a variable number of parties,
it follows that there may be parties in the census who are not identified by the proof arguments.
Such un-enumerated parties will receive any broadcasts and participate in any active replication that applies to the whole census,
but there's no way to specify them as the senders of messages, nor is there any way to specify that they should receive a message
except by broadcasting it.
For this reason, when we speak of "census polymorphism",
we mean \emph{useful} polymorphism that lets an unspecified quantity of parties actively participate in the choreography.
For example one might wish to write a \inlinecode{gather} operation
in which a polymorphic list of participants each send a computed value to a common recipient who aggregates them.
\Cref{fig:census-poly-example} shows an example \MultiChor choreography for a key-value store with a polymorphic list of backup servers.
In \Cref{sec:mpc} we implement the GMW protocol~\cite{goldreich2019play}, a foundational protocol in multi-party cryptography.
In earlier CP systems it would have been necessary to hard-code the number of participants when writing such choreographies;
Census polymorphism is precisely the absence of such a restriction.
Census polymorphism is achieved in \MultiChor library by type-level programming in modern Haskell.

\begin{figure*}[tbhp]
  \begin{mdframed}
    \inputminted[xleftmargin=10pt,linenos,fontsize=\scriptsize]{haskell}{figures/kvs_poly.hs.txt}
    \caption{
        A key-value store choreography with an unspecified number of backup servers.
        The main action happens in \inlinecode{handleRequest},
        a choreography involving only the servers which is called via \inlinecode{enclave} on line 21.
        \inlinecode{handleRequest}'s census explicitly includes the primary server, but is polymorphic over the list of backup servers.
        The primary server broadcasts the request (line~5--12); the backups will update their state and report their health
        only for a \inlinecode{Put} request.
        On line 7 the backups call the local IO function \inlinecode{handlePut} in \inlinecode{parallel} using their individual state references;
        \inlinecode{oks} is therefore a \inlinecode{Faceted backups '[] Response}.
        (The extra \inlinecode{'[]} denotes that no party yet knows all of the \inlinecode{oks}.)
        \inlinecode{gather} (line 8) communicates all the \inlinecode{oks} to the primary server
        where they're stored as a \inlinecode{Quire backups Response}.
        If all the backups are ok, then the primary server also handles the request (line 10).
    }
    \label{fig:census-poly-example}
    %\Description{23 lines of Haskell code using MultiChor defining a new version of "kvs" that is parametric over the number of backup servers.}
  \end{mdframed}
\end{figure*}

\subsection{Loops, Facets, and Quires}
\label{sec:census-poly-requirements}

The first thing that is necessary is a way to loop over a polymorphic list of parties.
Census polymorphism as discussed in this work is \emph{static},
\ie, while one can write choreographies and choreographic functions that are census-polymorphic,
it is always possible in principal to unroll the top-level choreography
(that actually gets compiled)
into a monomorphic form before you actually run anything.
In \Cref{sec:census-poly-haskell} we discuss \MultiChor's \inlinecode{sequenceP},
a runtime loop over statically-defined type level lists.

Less flexible options would still be viable.
The most recent versions of ChoRus and ChoreoTS lack constructs analogous to \inlinecode{sequenceP},
and instead offer the pair of functions \inlinecode[rust]{fanOut} and \inlinecode[rust]{fanIn}\cite{batesenclaves}.
These are both "for loops" over parties;
\inlinecode[rust]{fanOut}'s return type is a heterogeneous structure of the returned values for each looped-over party
(see next paragraph)
and \inlinecode[rust]{fanIn} works similarly except the owners of the aggregated data do not vary over the loop.
It's an open question whether the additional flexibility of \MultiChor's approach has any real-world use!
We also conjecture that even more restricted implementations would suffice for a majority of use-cases,
specifically by offering the three operations \inlinecode{scatter}, \inlinecode{gather}, and \inlinecode{parallel}.
\inlinecode{scatter} is multi-cast operation in which a distinct value is sent to each recipient, and \inlinecode{gather} is its dual.
\inlinecode{parallel} is exactly like \inlinecode{locally}, except a list of parties execute the local computation in parallel.
In \MultiChor, these are derived operations, and we use them frequently in our case studies.

The second thing required for useful census polymorphism is the ability to express and use divergent data known by un-enumerated parties.
We call such data structures \emph{faceted values}\footnote{
    The word "faceted" is most commonly used in reference to a cut gemstone,
    but analogy to the facets of polyhedral playing dice might be more on-the-nose.
}.
(They're basically the same as the faceted values introduced in \cite{austin2012},
except their public facet is always "$\bot$" and multiple parties have distinct private facets.)
Conceptually, a faceted value is similar to an MLV,
in that
it projects to an owner as a simple value and to a non-owner as a placeholder,
but different owners of a faceted value will have different values for it.
To see the need for faceted values, consider how one would express a census-polymorphic \inlinecode{gather} operation
using only a type-level \inlinecode{for}-loop:
The argument couldn't simply be a list,
because \inlinecode{Located} values with different owners have different types.
Each sender would need to generate its value to send \emph{inside} the loop body,
and the only way for the sent values to be distinct would be by using private local state accessed by \inlinecode{locally}.
This would hardly be satisfying, and the dual case of \inlinecode{scatter} would be even worse:
Any use to which the received values were to be put would also have to fit inside the body of the \inlinecode{for}-loop.
Again, one couldn't simply append the \inlinecode{scatter}ed values to a list and return it
because (in Haskell) all the values in a list must have the same type.

The dual of a faceted value is a "quire"\footnote{
    "Quire" is pronounced "choir"; it rhymes with "buyer" and means "a stack of sheets of paper, all cut to the same size".
    Each individual piece of paper is a "leaf".
},
a vector of values indexed by type-level parties.
Quires are not inherently located, but they can be located the same way as any other data structure.
For example, the return type of \inlinecode{gather} is
\inlinecode{Located recipients (Quire senders a)}.

\subsection{Census Polymorphism in \MultiChor}
\label{sec:census-poly-haskell}

We leverage the type system of modern Haskell to achieve useful census polymorphism in \MultiChor.
This behavior is implemented as a layer \textit{on top of} \MultiChor's central monad and data-types;
from a theory perspective \MultiChor gets census polymorphism "for free" because it's a Haskell library.
(Therefore, we do not bother with a separate proof of the soundness of census polymorphism.)
The \MultiChor repository contains over a dozen example choreographies, several of which use census polymorphism.
In Figure~\ref{fig:census-poly-example} we showcase a key-value store choreography that's polymorphic over the number of backup servers.
\Cref{sec:mpc} presents a more involved census-polymorphic example.

Key to \MultiChor's strategy is Haskell's ability to express quantified type variables.
For example, a \inlinecode{Faceted} value is (underneath a little boiler-plate) a function.
Its argument is a \inlinecode{Member} proof that some party is in the list of owners,
and it returns a \inlinecode{Located} value known to the party in question.
Notably, nothing about the type, \inlinecode{Faceted ps cmn x}, indicates who the (type-level!) party indicated by the argument might be.
(The second type parameter, \inlinecode{cmn}, represents parties who know \emph{all} the contained values;
it's frequently \inlinecode{'[]}.)

\inlinecode{Faceted ps cmn x} is actually a special case of a more general type,
\inlinecode{PIndexed ps f}, where \inlinecode{f} can be any \emph{type-level function} from a party to a concrete type.
A \inlinecode{PIndexed} is like a type-indexed vector,
except that the type of the value retrieved depends on the index.
(The case where it does not depend on the index, \ie when \inlinecode{f} is \inlinecode{Const},
is precisely \inlinecode{Quire}.)
Because of its unusual \inlinecode{kind}, type classes that one would expect to apply to vectors generally do not apply to \inlinecode{PIndexed}.
What's actually needed for census polymorphism is the ability to \inlinecode{sequence} a \inlinecode{PIndexed} of choreographies.
Since \inlinecode{PIndexed} is not an instance of \inlinecode{Traversable},
we implement the needed function \inlinecode{sequenceP}, which is effectively just a \inlinecode{for}-loop
(in any monad) over type-level lists of parties.
These loops are not unrolled at compile time;
the type class \inlinecode{KnownSymbols} affords to the runtime environment sufficient knowledge of the type-level list.

\begin{figure*}[tbhp]
  \begin{mdframed}
    \inputminted[xleftmargin=10pt,linenos,fontsize=\scriptsize]{haskell}{figures/census-poly-haskell.hs.txt}
    \caption{
        Type signatures for \inlinecode{sequenceP}, \inlinecode{fanOut}, and \inlinecode{scatter}.
    }
    \label{fig:census-poly-haskell}
    %\Description{Fourteen lines of Haskell code using the MulitChor library.}
  \end{mdframed}
\end{figure*}

The type-level programming necessary to use \inlinecode{sequenceP} and \inlinecode{PIndexed} directly
can involve some boilerplate.
We provide the derived functions \inlinecode{fanOut} and \inlinecode{fanIn}
which suffice for every situation studied so far.
\inlinecode{fanOut}'s argument is a choreography that results in a \inlinecode{Located} value at the party identified by the loop variable;
it aggregates these results as a \inlinecode{Faceted}.
\inlinecode{fanIn} is almost the same, except that the locations of the resulting values do not vary,
and they are aggregated in a \inlinecode{Quire} located at some list of recipients.
\Cref{fig:census-poly-haskell} shows the type signatures for \inlinecode{sequenceP}, \inlinecode{fanOut}, and \inlinecode{scatter}.
Keen readers may notice that the "\inlinecode{cmn}" parties' views of a \inlinecode{Faceted} are effectively just a \inlinecode{Quire},
and so wonder at the need for \inlinecode{fanIn}.
In fact, \inlinecode{fanIn} \emph{is} less often used than \inlinecode{fanOut},
but it's necessary for expressing choreographic loops that yield values which aren't known to the parties over whom the loop is defined.
For example, the GMW protocol, which we implement using \MultiChor in \Cref{sec:mpc}, cannot be written using only \inlinecode{fanOut}.

Modern Haskell language features, especially type-variable quantification,
enable \MultiChor's implementation of census polymorphism to be entirely type-safe and transparent to users.
This is a flexible system within which users can easily write their own novel and bespoke functions and data structures.


\section{The GMW Protocol in MultiChor}
\label{sec:mpc}

\emph{Secure multiparty computation}~\cite{evans2018pragmatic} (MPC) is a family of techniques that allow a group of parties to jointly compute an agreed-upon function of their distributed data without revealing the data or any intermediate results to the other parties. We consider an MPC protocol named Goldreich-Micali-Widgerson (GMW)~\cite{goldreich2019play} after its authors. The GMW protocol requires the function to be computed to be specified as a binary circuit, and each of the parties who participates in the protocol may provide zero or more inputs to the circuit. At the conclusion of the protocol, all participating parties learn the circuit's output.

The GMW protocol is based on two important building blocks: \emph{additive secret sharing}, a method for encrypting distributed data that still allows computing on it, and \emph{oblivious transfer} (OT)~\cite{naor2001efficient}, a building-block protocol in applied cryptography. The GMW protocol starts by asking each party to secret share its input values for the circuit. Then, the parties iteratively evaluate the gates of the circuit while keeping the intermediate values secret shared. Oblivious transfer is used to evaluate AND gates. When evaluation finishes, the parties reveal their secret shares of the output to decrypt the final result.

\begin{figure*}[tbhp]
  \begin{mdframed}
    \inputminted[xleftmargin=10pt,linenos,fontsize=\scriptsize]{Haskell}{figures/gmw.hs.txt}
    \caption{A choreography for the GMW protocol. The choreography works for an arbitrary number of parties.
      \Cref{fig:gmw-helpers-multichor-example} contains the \inlinecode{xor} function to compute the OR gate,
      the \inlinecode{secretShare} choreography to handle an INPUT,
      and the \inlinecode{fAnd} choreography to compute the result of an AND gate.
	  \inlinecode{mpc} uses \inlinecode{gmw} protocol as well as \inlinecode{reveal}
	  (also in \Cref{fig:gmw-helpers-multichor-example}, and prints the resulting bit at each party.}
    \label{fig:gmw-multichor-example}
  \end{mdframed}
    %\Description{Thirty one lines of Haskell code using the MultiChor library.
%	This code defines a recursive choreographic function "gmw" and a top-level function "mpc".}
\end{figure*}

\begin{figure*}
  \begin{mdframed}
    \inputminted[xleftmargin=10pt,linenos,fontsize=\scriptsize]{Haskell}{figures/gmw-helpers.hs.txt}
    \caption{Various helpers for the GMW protocol.
      \inlinecode{fANd} computes the result of an AND gate on secret-shared inputs using pairwise oblivious transfer. The choreography works for an arbitrary number of parties, and leverages the 1 out of 2 OT defined earlier.
      \inlinecode{xor} computes the result of an OR gate as a standard non-choreographic function.
      \inlinecode{secretShare} handles Input gate secret sharing \inlinecode{p}'s secret value among \inlinecode{parties}
         and for revealing a secret-shared value.
      \inlinecode{ot} performs 1 out of 2 oblivious transfer (OT) using RSA public-key encryption. The choreography involves exactly two parties, \inlinecode{sender} and \inlinecode{receiver}.
      \inlinecode{genShares} uses \inlinecode{Quire} to map each member \inlinecode{p} in \inlinecode{ps} to a generated secret share \inlinecode{Bool}.
      \inlinecode{encryptS} \inlinecode{decryptS} which are omitted for brevity use the cryptonite library for encryption and decryption.
    }
    \label{fig:gmw-helpers-multichor-example}
  \end{mdframed}
    %\Description{Fifty nine lines of Haskell code using the MultiChor library.
%	This code defines functions "secretShare", "genShares", "xor", "fAnd", "ot2", and "reveal".}
\end{figure*}

\paragraph{Additive secret sharing}
We begin by describing additive secret sharing, a common building block in MPC protocols. A secret bit $x$ can be \emph{secret shared} by generating $n$ random \emph{shares} $s_1, \dots, s_n$ such that $x = \sum_{i=1}^n s_i$. If $n-1$ of the shares are generated uniformly and independently randomly, and the final share is chosen to satisfy the property above, then the shares can be safely distributed to the $n$ parties without revealing $x$---recovering $x$ requires access to all $n$ shares. Importantly, secret shares are \emph{additively homomorphic}---adding together shares of secrets $x$ and $y$ produces a share of $x+y$.

\MultiChor choreographies for performing secret sharing in the arithmetic field of booleans appear in Figure~\ref{fig:gmw-helpers-multichor-example}. The function \inlinecode{secretShare} takes a single secret bit located at party \inlinecode{p}, generates \inlinecode{shares},
a \inlinecode{Quire} which maps each member in \inlinecode{parties} to a share,
and then uses \inlinecode{scatter} to send the assigned share to each member.
However \inlinecode{scatter} would return a \inlinecode{Faceted parties '[p] Bool} since by default it includes the sender.
The choreographic function \inlinecode{gmw} expects shares of wires to be secret,
so we must return a \inlinecode{Faceted parties '[] Bool}.
We accomplish this by deconstructing and reconstructing via \inlinecode{PIndexed},
and using \inlinecode{othersForget (First @@ nobody)}.
The resulting \inlinecode{Faceted} "bit" actually represents the differing values located at all parties;
the bits held by the parties sum up to the original secret.
\inlinecode{reveal} takes exactly such a shared value and broadcasts
all the shares so everyone can reconstruct the plain-text.

\paragraph{Oblivious transfer}
The other important building block of the GMW protocol is oblivious transfer (OT)~\cite{naor2001efficient}. OT is a 2-party protocol between a \emph{sender} and a \emph{receiver}. In the simplest variant (\emph{1 out of 2} OT, used in GMW), the sender inputs two secret bits $b_1$ and $b_2$, and the receiver inputs a single secret \emph{select bit} $s$. If $s=0$, then the receiver receives $b_1$. If $s=1$, then the receiver receives $b_2$. Importantly, the sender does \emph{not} learn which of $b_1$ or $b_2$ has been selected, and the receiver does \emph{not} learn the non-selected value.

Importantly, oblivious transfer is a \emph{two-party protocol}, it would be a type-error for any third-parties to be involved in the implementation. \MultiChor's \inlinecode{Faceted} values and utilities for type-safe embedding of enclaved sub-protocols within arbitrarily large censuses make it possible to embed the use of pairwise oblivious transfer between parties in a general version of multi-party GMW.

\paragraph{The GMW protocol}
The complete GMW protocol operates as summarized earlier, by secret sharing input values and then evaluating the circuit gate-by-gate. Our implementation as a \MultiChor choreography appears in Figure~\ref{fig:gmw-multichor-example}, defined as a recursive function over the structure of the circuit. The choreography returns a \inlinecode{Faceted} value, representing the secret-shared output of the circuit. For ``input'' gates (lines~4--6), the choreography runs the secret sharing protocol in Figure~\ref{fig:gmw-helpers-multichor-example} to distribute shares of the secret value. For XOR gates (lines~16--18) Figure ~\ref{fig:gmw-multichor-example}, the parties recursively run the GMW protocol to compute the two inputs to the gate and then each party computes one share of the gate's output by XORing their shares of the inputs. This approach leverages the additive homomorphism of additive secret shares. For AND gates (lines~13--15) Figure ~\ref{fig:gmw-multichor-example}, the parties compute shares of the gate's inputs, then use the \inlinecode{fAnd} protocol to perform multiplication of the two inputs. This implements the protocol as described in  Section 3.2.1 of \cite{evans2018pragmatic} namely the \emph{Generalization to more than two parties} case. Since additive secret shares are not multiplicatively homomorphic, this operation leverages the oblivious transfer protocol to perform the multiplication.

\paragraph{Computing secret-shared AND via OT}
To compute the result of an AND gate, the parties compute \emph{pair-wise} ANDs using their respective shares of the input values, then use the results to derive shares of the gate's output. The \inlinecode{fAnd} choreography (Figure~\ref{fig:gmw-helpers-multichor-example} lines~17--39) takes \inlinecode{Faceted} values holding the parties' shares of the input values, and returns a \inlinecode{Faceted} value representing each party's share of the output. On line~25, the parties perform a \inlinecode{fanOut} to begin the pairwise computation; the \inlinecode{fanIn} on line~27 completes the pairing for each computation, and uses \inlinecode{enclaveTo} (line 34) to embed pairwise OTs (via \inlinecode{ot2}) in the larger set of parties.

Our implementation of GMW leverages \MultiChor's \inlinecode{Faceted} values and utilities for type-safe parallel, enclaved, and pairwise choreographies to build a fully-general implementation of the protocol that works for an arbitrary number of parties.

\bibliographystyle{chicago}
\bibliography{refs}
