\chapter{Real World Choreographic Programming}
\chaptermark{\MultiChor?} %this is the chapter heading that will show on subsequent pages
\label{sec:multichor}

\begin{quote}
Paper abstract
\end{quote}


\section{Introduction}
In this chapter we demonstrate the practicality of enclaves-\&-MLVs choreographic programming
by presenting our implementation:
the \MultiChor Haskell library.
\MultiChor is a "just a library" CP system in the style of HasChor.
We adopt HasChor's freer-monads and handlers design pattern,
and embed the key aspects of \HLSCentral's type system as type-level constraints with a bespoke proof-witness system.

A key innovation of \HLSCentral is that KoC is enforced entirely
by type-level management of the census.
By representing the census as a type-level variable in Haskell,
\MultiChor enables polymorphism over both the size and membership of the census,
a feature not considered in the construction of \HLSCentral.
All Haskell typing happens statically, and \MultiChor's EPP happens at runtime (like HasChor's).
This means that, like other cases of polymorphism in Haskell, location polymorphism in \MultiChor must be resolved statically.

A few other desiderata motivate our implementation:
\begin{enumerate}
    \item It should be possible to broadcast, \ie to multicast a value to the entire census,
          and to use values known to the entire census as normal (un-located) values of their type.
    \item It should be possible to know from an appropriately-written choreography's type that some
          certain party or parties are not involved, are not in its census.
          Users should be able to embed such "enclave" choreographies inside choreographies with larger,
          possibly polymorphic, censuses.
    \item The type system should be able to reason about parties'
          membership in a census or ownership-set
          with normal subset reasoning.
\end{enumerate}
The choreography in Figure~\ref{fig:card-game} showcases the above points.
The census of the whole program appears in the type
and does not specify who the players are.
The \inlinecode{enclaveTo} on line~18
embeds a choreography whose census is exactly the monomorphic \inlinecode{"dealer"}
and a polymorphic \inlinecode{player} (\#2).
The helper-function \inlinecode{broadcast} on line 19 functions as described in \#1.
Many examples of \#3 are automated or hidden in \MultiChor,
but on line~19 the function \inlinecode{inSuper} is applied to
\inlinecode{players :: Subset players ("dealer" : players)}
and \inlinecode{player :: Member player players}
to attest that \inlinecode{player} is present in the census.

\begin{figure*}[tbhp]
    \begin{mdframed}
    \inputminted[xleftmargin=10pt,linenos,fontsize=\scriptsize]{haskell}{figures/census-poly-example.hs.txt}
    \caption{A card game expressed as a choreography written in \MultiChor.
             This choreography is polymorphic over the number and identity of the players,
             but the party named \inlinecode{"dealer"} is an explicit member.
             The inner monad \inlinecode{CLI} that all parties have access to is a simple freer monad
             that can be handled to IO operations, or as \inlinecode{State} for testing purposes.
             The \inlinecode{newtype Card} encapsulates the modulo operation in its
             \inlinecode{Num} instance.}
    \label{fig:card-game}
    %\Description{Thirty lines of haskell code describing a choreography called "game".}
    \end{mdframed}
\end{figure*}


\subsection{Censuses, Enclaves, and MLVs in Haskell}
\label{sec:multichor}

\MultiChor uses the same free-monad approach as \HasChor~\cite{shen-haschor} to implement choreographic programming, EPP,
and the final interpretation to a real communication mechanism.
Also like \HasChor, \MultiChor's \inlinecode{Choreo} monad is parameterised by a \emph{local monad} in which parties' local computations can be expressed.
A \MultiChor type \inlinecode{Located ps t} is a multiply-located \inlinecode{t} owned by the parties \inlinecode{ps}.
It is possible to write \MultiChor functions that look and work like each of \HasChor's three primitive operators,
but the derived API in which users write \MultiChor choreographies contains a clear analog of only one of \HasChor's primitives.
Haskell's monadic-\inlinecode{do} notation and purity-oriented type system make \MultiChor code concise and safe
(in the sense that users are unlikely to accidentally invalidate important invariants).

As explained in Section~\ref{sec:formalism},
our KoC strategy requires that the correctness (well-typed-ness) of choreographies be judged in the context of a census.
\MultiChor adds the census as a type parameter of the \inlinecode{Choreo} monad.
Its kind is \inlinecode{[Symbol]},
which is to say that the census is a type-level list of parties and parties are type-level strings.
\inlinecode{Choreo} is \emph{not} an \emph{indexed} monad (that is, executing a monadic operation doesn't change the census),
but monadic operations can take choreographies with smaller censuses as arguments.

The fundamental operations of \MultiChor's \inlinecode{Choreo} monad are
\inlinecode{enclave}, \inlinecode{broadcast'}, \inlinecode{locally'}, and \inlinecode{congruently'}.
Their type signatures are given in \Cref{fig:operators-multichor}.
Like in \HasChor, these are free-monad constructors; their behavior is implemented in interpreters
that carry out EPP or implement a centralized semantics.
Three of them have their names "primed" because the un-primed versions of these names are reserved for more ergonomic derived functions.
For example, \inlinecode{locally'} takes a single argument, a computation in the local monad, and requires that the census contains
\emph{a single party}, who will execute that computation.
The un-primed \inlinecode{locally} takes an additional argument that identifies a single party from a larger census;
it uses \inlinecode{enclave} to correctly call \inlinecode{locally'}.
\inlinecode{broadcast} shares a \inlinecode{Located} value with the entire census so the unwrapped value can be used;
by combining this with \inlinecode{enclave} we can implement point-to-point or multicast communication.
From the perspective of a centralized semantics, \inlinecode{enclave} doesn't do anything at all besides run
the sub-choreography,
but EPP to a party \emph{not} in the sub-census skips the sub-choreography and just returns \inlinecode{Empty}.

\inlinecode{congruently} lets us leverage MLVs to concisely write actively-replicated computations.
In contrast to \inlinecode{locally}, the computation is performed by multiple parties
and the result is multiply-located across all of them.\footnote{
    The entire census participates in the primed version, and its result is returned naked.
    The behavior of \inlinecode{enclave} and the more fundamental rules of monadic programming
    ensure the un-primed \inlinecode{congruently} behaves correctly.
}
For the execution of these actively-replicated computations to correctly return an MLV,
all the parties must be guaranteed to be doing a pure computation on the same data.
Haskell makes it easy to enforce such a guarantee to a practical (but not unbreakable) extent.
This is why \inlinecode{congruently} does not grant access to the local monad \inlinecode{m}.
It also requires that the computation not have access to the specific identity of the computing party,
unlike \inlinecode{locally} and the similar-looking function \inlinecode{parallel} mentioned in \Cref{sec:census-poly}.
Weakening (or subverting) these restrictions would allow a user to violate \MultiChor's invariant that MLVs (\inlinecode{Located} values)
have the same value across all their owners.

It is critical to the safety of \MultiChor that the projection of a choreography to any given party will not use
any other party's \inlinecode{Located} values.
We use the same basic strategy for this as \HasChor:
\inlinecode{Located}'s constructors, \inlinecode{Wrap} and \inlinecode{Empty}, are hidden inside the core module
and afforded only by dependency injection to \inlinecode{locally} and \inlinecode{congruently}.
The specific "unwrapper" functions afforded to \inlinecode{locally} and \inlinecode{congruently}
are known to user code only by their type signatures, which have respective aliases \inlinecode{Unwrap} and \inlinecode{Unwraps}.
\inlinecode{Located}'s constructors are also used by two less-critical functions, \inlinecode{flatten} and \inlinecode{othersForget}.
These are needed for shrinking ownership sets or un-nesting \inlinecode{Located} values;
they could be written using \inlinecode{congruently},
but by implementing them in the core module where they can pattern-match \inlinecode{Located} values we are able to make them not-monadic,
and so more convenient.

\begin{figure*}[tbhp]
  \begin{mdframed}
    \inputminted[xleftmargin=10pt,linenos,fontsize=\scriptsize]{haskell}{figures/operators-multichor.hs.txt}
    \caption{
        The fundamental operators for writing expressions in \MultiChor's \inlinecode{Choreo} monad.
        Of these four operators, \inlinecode{enclave} is the only one users will usually call directly;
        the other three can combine with each other (and with \inlinecode{enclave}) to make more user-friendly alternatives.
    }
    \label{fig:operators-multichor}
    %\Description{Four type signatures for Haskell functions using the MultiChor library.}
  \end{mdframed}
\end{figure*}

\todo{BEYOND HERE IS STRAIGHT COPY-PASTA FROM THE OLD MULTICHOR PAPER.}

\paragraph{Reasoning about location-sets}
\todo{Probably mostly replace this with the version from the enclaves paper.}
To illuminate point 5 above, consider the program in Figure~\ref{fig:example-transitive},
a choreography with a polymorphic census \inlinecode{census}.
For this to be a well-formed choreography, all of the following must be true
(to support the parenthesized statements):
\begin{itemize}
    \item \inlinecode{clique} must be a subset of \inlinecode{census}.
          (\inlinecode{enclave} on line~3)
    \item \inlinecode{bob} must be a member of \inlinecode{census}.
          (\inlinecode{~>} ("send") on line~4)
    \item \inlinecode{bob} must be a member of \inlinecode{clique}.
          (\inlinecode{~>} on line~6, as well as \inlinecode{~>} on line~4 so they can use \inlinecode{theirFoo})
\end{itemize}
Notice that one of these prerequisites is redundant:
if Bob is a member of \inlinecode{clique}, and \inlinecode{clique} is a subset of \inlinecode{census},
then \emph{it follows} that Bob is a member of \inlinecode{census}.
When all the sets of parties are explicitly listed out, memberships and subsets can simply be observed,
but reasoning about polymorphic sets is difficult for Haskell's type system.
Leveraging the transitivity of subset relations is especially difficult~\cite{stackoverflow2021},
and without such reasoning it's difficult to write reuseable code.
We overcome this challenge using Ghosts of Departed Proofs~\cite{noonanGDP};
the proof-objects do double-duty in \MultiChor as both proofs that operations are legal \emph{and}
as \inlinecode{Proxy}-like identifiers for type-level parties and lists of parties.

\begin{figure*}[tbhp]
    \begin{mdframed}
\begin{minted}[xleftmargin=10pt,linenos,fontsize=\small]{haskell}
exampleChor :: Choreo census m (Located '["carroll"] Int)  -- The inner monad m is not used here.
exampleChor = do
    theirFoo <- clique `enclave` foo  -- Lift a Choreo of "clique" into a Choreo of "census".
    (bob, theirFoo) ~> carroll @@ nobody  -- Bob sends `theirFoo` to Carroll (and nobody else).
  where foo = do
          aliceFoo <- (bob, bobFoo) ~> alice @@ nobody  -- Bob sends his value `bobFoo` to Alice.
          broadcast (alice, aliceFoo)  -- Alice sends it to the census of `foo`,
                                       -- _not_ the census of `exampleChor`.
\end{minted}
    \caption{An example choreography, written with \MultiChor, in which an \inlinecode{Int},
             originating at a party \inlinecode{bob}, is passed back and forth.
             Ultimately, a version of that value owned only by \inlinecode{carroll} is returned.
             Part of the choreography takes place in an \inlinecode{enclave}
             involving some collection of parties specified by \inlinecode{clique}.}
    \label{fig:example-transitive}
    %\Description{Eight lines of haskell code describing a choreography called "exampleChor".}
    \end{mdframed}
\end{figure*}

\paragraph{Congruent computation}
One of the attractive features of multiply-located values is that they allow concise expression of
congruent computations.
A \emph{congruent} computation is one that is performed in parallel by multiple parties
deterministically on \emph{the same} values, such that all parties arrive at the same result
(\textit{e.g.} Figure~\ref{fig:lottery} line~37).
This is distinct from a \emph{parallel} computation
(\textit{e.g.} Figure~\ref{fig:lottery} line~26), whose distributed versions are expressed
by the same possibly-branching algorithm but might be operating on different data
and arrive at different results.
Parallel computation is more heavily studied and more widely used;
congruent computation is desirable when communication is more expensive (slower)
than local computation.
We believe a choreography library should support both congruent and parallel computation
as part of type-safe use of located values.


\subsection{Location-set and census polymorphism}\label{sec:located-faceted}

Being a proof-of-concept lambda calculus, \HLSCentral doesn't support polymorphism of data-types
or of locations.
\HasChor has a blunter API for writing choreographies, but as an eDSL it can apply
Haskell's polymorphism "for free".
\MultiChor is a similar eDSL, with some of \HasChor's skeleton intact at its heart,
and can similarly apply Haskell's polymorphism to its \emph{lists} of parties.
(In addition to polymorphism over a census, \MultiChor expressions
can also be polymorphic over lists of data-owners;
it's rarely important to distinguish between these features.)
Without complementary features this would be
unsatisfying---the only way an unidentified and variable mass of parties in a census could actually
participate is as recipients of broadcasts.

The first step toward \emph{useful} location-set polymorphism is a data type analogous to
multiply-located values (\inlinecode{Located (ps::[LocTy]) a} in \MultiChor)
but without the guarantee that the parties' respective values will all the the same.
We call such structures \inlinecode{Faceted}, after the many facets that form
the surface of a cut gem-stone.
This language feature immediately enables an operation similar to \HasChor's \inlinecode{locally},
except that \MultiChor's \inlinecode{parallel} is evaluated by a list of locations.
The block in Figure~\ref{fig:card-game} lines~13--16 has type 
\inlinecode{Choreo ... (Faceted players Bool)}
and yields a single "value" that \emph{represents} the likely-different booleans read from
\inlinecode[text]{stdin} by the (polymorphic) parties \inlinecode{players}.
\inlinecode{Faceted} values can be multicast by their owners
and used in future \inlinecode{parallel} blocks
just like \inlinecode{Located} values.

\paragraph{Fan-Out and Fan-In}
\inlinecode{Faceted} values are still insufficient for two tasks we believe a location-set polymorphic
choreography library should support:
\begin{enumerate}%[leftmargin=12pt, itemsep=0pt]
  \item A party should be able to send each member of a polymorphic list a \emph{distinct} value.
  \item The members of a polymorphic list should be able to \emph{send} messages.
\end{enumerate}
We accomplish these with two subtly different primitives:
\inlinecode{fanOut} and \inlinecode{fanIn}.
Both take as an argument a choreography with a single-location parameter,
and instantiate the choreography with each member of the specified location set,
like a \inlinecode[text]{foreach} loop.
In the case of \inlinecode{fanOut}, the loop-body is required to return a value at the subject 
location;
these values get packaged together as a \inlinecode{Faceted}.
For \inlinecode{fanIn}, the return value must be located at a \emph{consistent} set of recipients;
the values get packaged as a \inlinecode{Located recipients [value]}.
Both of these operations are used in Figure~\ref{fig:card-game}.


\subsection{The Core API}\label{sec:monad}

The \MultiChor API features seven primitive monadic operations,
from which a collection of utilities can be built.
Additionally, there's a suite of pure operations for handing membership and subset proofs,
and some limited operations which can manipulate \inlinecode{Located}
and \inlinecode{Faceted} values.

\paragraph{Pure operations for proofs}
\MultiChor's API uses proof objects both to identify parties and sets of parties,
and as assurance that those parties will be able to perform the described actions at runtime.
In all cases, these are proofs that the identified party is a member of some set
or that the identified set is a subset of some other set.
The suite of operations for building such proofs is founded on four uses of
\inlinecode[text]{gdp}'s \inlinecode{Logic.Proof.axiom}
and instances for \inlinecode{Subset} of \inlinecode{Logic.Classes.Reflexive}
(which affords the proof \inlinecode{refl})
and \inlinecode{Transitive} (which affords the proof \inlinecode{transitive})~\cite{gdp_hackage}.
In situations where the census and all identities are known explicitly,
the proofs \inlinecode{explicitMember} and \inlinecode{explicitSubset} may be used indiscriminately.
(These rely on respective type classes \inlinecode{ExplicitMember}/\inlinecode{ExplicitSubset},
the limitations of which are part of the motivation for using
\inlinecode[text]{gdp}.)
A Template Haskell helper \inlinecode{mkLoc} specializes \inlinecode{explicitMember} for a given 
symbol, allowing easy, clear, and precise reference to monomorphic parties.

Specifying a list of parties via subset proof can be finicky.
To facilitate, the API offers aliases of two of the axioms
than can be used analogously to the empty-list and list-cons constructors:
%
\begin{minted}[xleftmargin=10pt,fontsize=\small]{haskell}
nobody :: Subset '[] ys
(@@) :: Member x ys -> Subset xs ys
     -> Subset (x ': xs) ys
\end{minted}
%
For example, in Figure~\ref{fig:card-game} line~18, the first argument to the
\inlinecode{enclaveTo}
says that the census of the enclave is
\inlinecode{"dealer"} and \inlinecode{player} and nobody else.

\paragraph{Pure operations for located values}
\inlinecode{Located} and \inlinecode{Faceted} are both instances of \inlinecode{Wrapped},
indicating that these values can be \inlinecode{un}-wrapped in an appropriate context.
Almost every operation on \inlinecode{Located} and \inlinecode{Faceted} values is dependent
on a relevant census, and so must be performed as part of the \inlinecode{Choreo} monad.
Exceptions pertain to reinterpreting the wrapper-type itself, not the contained data.
Most of these are uninteresting,
but \inlinecode{flatten} is indispensable and must be considered part of the core API.
%
\begin{minted}[xleftmargin=10pt,fontsize=\small]{haskell}
flatten :: Subset ls ms -> Subset ls ns
        -> Located ms (Located ns a) -> Located ls a
\end{minted}
%
\inlinecode{flatten} un-nests \inlinecode{Located} layers to parties listed in both layers.
In practice, its primary use is inside the helper-function \inlinecode{enclaveTo};
in Figure~\ref{fig:card-game} line~18 the second argument says
"the second party listed in the census (\inlinecode{player}) knows the return value",
and gets passed to \inlinecode{flatten} so that the result of the enclaved choreography
isn't doubly-\inlinecode{Located}.
(An alternative API, in which \inlinecode{enclave} didn't add a layer of wrapping but
required it's return to be located, would be less expressive.)

\paragraph{Monadic primitives}
The \inlinecode{Choreo} monad is implemented as a freer monad with an explicit census
and an inner-monad type parameter representing
the local computational model of all parties individually.
The underlying data-type has seven constructors, each exposed as a function;
Figure~\ref{fig:monad-api} shows their types and describes their arguments.
\begin{itemize}%[leftmargin=12pt, topsep=2pt]
    \item \inlinecode{parallel} runs a local monadic computation in parallel across a list of parties.
          This computation can depend on the identity of the party in question,
          and can use a provided function to unwrap \inlinecode{Located} and \inlinecode{Faceted}
          values.
          The return type is \inlinecode{Faceted} across the relevant parties.
    \item \inlinecode{congruently} runs a pure computation congruently across a list of parties;
          since the values represented by a \inlinecode{Faceted} aren't congruent,
          \inlinecode{congruently} can't use them.
          Since the returned values are congruent,
          \inlinecode{congruently} returns a \inlinecode{Located} value at all of the listed parties.
    \item \inlinecode{comm} is the communication operator;
          it multicasts from a single sender to a list of recipients.
          The result is \inlinecode{Located}.
          See Section~\ref{sec:helpers} for the more user-friendly \inlinecode{~>}.
    \item \inlinecode{enclave} embeds a choreography with a smaller census inside one whom's
          census is a superset.
          In addition to facilitating code-reuse, this is important when one wants to encode
          at the type level that certain parties are not involved in some sub-operation,
          and it interacts with \inlinecode{naked}.
    \item \inlinecode{naked} unwraps a single value that's known to the entire census.
          Monadic binding of \inlinecode{naked} with a continuation gives the same behavior
          as \HasChor's \inlinecode{cond} operation, except that instead of hiding an implicit
          broadcast it requires that any needed communication have already happened.
          Frequently, \inlinecode{naked} will be called inside \inlinecode{enclave};
          this gives the behavior of \HLSCentral's auto-enclaving "case" expressions.
    \item \inlinecode{fanOut} performs a given action parameterized by a party
          for each party in the given subset of the census.
          Unlike \inlinecode{parallel}, which describes actions in the local monad,
          \inlinecode{fanOut}'s body is a choreography over the complete census.
          Arbitrary choreographic behavior can happen inside \inlinecode{fanOut},
          including branching based on the parameter identity,
          so long as the returned value is known to that party and has the given type.
          The return values form a new \inlinecode{Faceted}.
    \item \inlinecode{fanIn} is similar to \inlinecode{fanOut}, but represents \emph{convergence}.
          The return value must be \inlinecode{Located} at a given set of "recipients"
          that do \emph{not} depend on the parameter identity.
          This doesn't necessarily imply any \inlinecode{~>} operations,
          but the obvious use-case is that each \inlinecode{q} in \inlinecode{qs}
          multicasts to \inlinecode{rs}.
          The likely-different return values are combined as a simple \inlinecode{Located} list;
          any other scheme for combining them can be implemented
          in a subsequent \inlinecode{congruently}.
\end{itemize}


\begin{figure*}[tbhp]
    \begin{mdframed}
\begin{minted}[xleftmargin=10pt,linenos,fontsize=\small]{haskell}
-- | Access to the inner "local" monad.
parallel :: Subset ls ps  -- A set of parties who will all perform the action(s) in parallel.
         -> (forall l. Member l ls -- The "loop variable", a party l in ls.
                    -> Unwrap l    -- A function for unwrapping Located or Faceted values
                                   --  known to l.
                    -> m a)  -- The local action(s).
         -> Choreo ps m (Faceted ls a)

-- | Congrunet computation.
congruently :: Subset ls ps  -- The set of parties who will perform the computation.
            -> (Unwraps ls -> a)  -- The computation does not depend on who's performing it.
                                  -- Unwraps doesn't work on Faceted values, unlike Unwrap.
            -> Choreo ps m (Located ls a)

-- | Communication between a sender and some receivers.
comm :: (Show a, Read a, Wrapped w)  -- Both Located and Faceted are instances of Wrapped.
                                     -- Show and Read are the ad-hoc serializaiton system.
     => Member l ps            -- ^ The sender, who is present in the census.
     -> (Member l ls, w ls a)  -- ^ Proof the sender knows the value, the value.
     -> Subset ls' ps          -- ^ The recipients, who are present in the census.
     -> Choreo ps m (Located ls' a)

-- | Lift a choreography of involving fewer parties into the larger party space.
enclave :: Subset ls ps  -- The sub-choreography's census must be in the outer census.
        -> Choreo ls m a  -- The sub-choreography.
        -> Choreo ps m (Located ls a)

-- | Un-locates a value known to the entire census.
naked :: Subset ps qs  -- Proof that everyone knows the value.
      -> Located qs a  --  The value.
      -> Choreo ps m a

-- | Perform a choreographic action for each of several parties,
--   gathering their return values as a `Faceted`.
fanOut :: (Wrapped w)
       => Subset qs ps  -- The parties to loop over.
       -> (forall q. Member q qs  -- The "loop variable", a party q in qs.
                  -> Choreo ps m (w '[q] a))  -- The "loop body", returns a value at q.
       -> Choreo ps m (Faceted qs a)

-- | Perform a given choreography for each of several parties;
--   the return values are aggregated as a list located at the invariant recipients.
fanIn :: Subset qs ps  -- The parties who are fanning-in, or over whom we're looping.
      -> Subset rs ps  -- The recipients, the parties who know the results.
      -> (forall q. Member q qs  -- The "loop variable", a party q in qs.
                 -> Choreo ps m (Located rs a))  -- The "loop body", returns a value at rs.
      -> Choreo ps m (Located rs [a])
\end{minted}
    \caption{The monadic functions for constructing \inlinecode{Choreo} expressions.}
    \label{fig:monad-api}
    %\Description{Forty-seven lines of haskell code, giving type signatures for seven functions.}
    \end{mdframed}
\end{figure*}


\subsection{Derived functions}\label{sec:helpers}
We aim for minimalism in engineering \MultiChor's core API to facilitate reasoning about
(and implementing) the freer monad handlers for the centralized semantics and for EPP.
At the same time, we aim for \MultiChor to be used in the wild,
and based on our experience writing examples
we believe that a suite of helper functions is in order.
Appendix~\ref{sec:extra-helpers} lists all the functions used in examples in this paper.
A few are especially common in practice:
\begin{itemize}%[leftmargin=12pt, topsep=2pt]
    \item \inlinecode{~>} wraps \inlinecode{comm}.
          In addition to being a convenient infix operator,
          it uses a dedicated class to accept different structures as its first argument.
          When explicit membership can be inferred by the type system,
          it suffices to identify the sender with a \inlinecode{Member sender census}.
          When all owners of the message are present in the census,
          one can use a \inlinecode{Subset owners census} and a \inlinecode{Member sender owners}.
          Otherwise, the usual proofs of presence and ownership will work.
    \item \inlinecode{~~>} sends the result of a local computation directly to recipients
          without binding it to an intermediary variable.
    \item \inlinecode{broadcast} takes the same argument options as \inlinecode{~>}
          and sends the message to the entire census;
          the received value is unwrapped by \inlinecode{naked}.
    \item \inlinecode{locally} wraps \inlinecode{parallel} for use on a single party;
          since there's only one actor, the return value can be \inlinecode{Located}
          instead of \inlinecode{Faceted}.
          Both \inlinecode{locally} and \inlinecode{parallel} have underscore-prefixed
          variants for when the action-lambdas would ignore their arguments,
          and underscore-suffixed variants for discarding \inlinecode{Located ps ()} results.
    \item \inlinecode{singleton} is a polymorphic proof that a party is a member of a list
          containing just themselves. 
\end{itemize}



\begin{figure*}
\begin{mdframed}
\begin{minted}[xleftmargin=10pt,linenos,fontsize=\small]{haskell}
kvs :: (KnownSymbol client) => ReplicationStrategy ps (CLI m) -> Member client ps -> Choreo ps (CLI m) ()
kvs ReplicationStrategy{setup, primary, handle} client = do
  rigging <- setup
  let go = do request <- (client, readRequest) -~> primary @@ nobody
              response <- handle rigging singleton request
              case response of Stopped -> return ()
                               _ -> do client `_locally_` putOutput "Recieved:" response
                                       go
  go

naryReplicationStrategy :: (KnownSymbol primary, KnownSymbols backups, KnownSymbols ps, MonadIO m)
                        => Member primary ps -> Subset backups ps -> ReplicationStrategy ps m
naryReplicationStrategy primary backups = ReplicationStrategy{
      primary
    , setup = servers `_parallel` newIORef (Map.empty :: State)
    , handle = \stateRef pHas request -> do
          request' <- (primary, (pHas, request)) ~> servers
          localResponse <- servers `parallel` \server un ->
              handleRequest (un server stateRef) (un server request')
          responses <- fanIn servers (primary @@ nobody) \server ->
              (server, servers, localResponse) ~> primary @@ nobody
          response <- (primary @@ nobody) `congruently` \un ->
              case nub (un refl responses) of [r] -> r
                                              rs -> Desynchronization rs
          broadcast (primary, response)   }
  where servers = primary @@ backups

data ReplicationStrategy ps m = forall primary rigging. (KnownSymbol primary) =>
  ReplicationStrategy { primary :: Member primary ps
                      , setup :: Choreo ps m rigging
                      , handle :: forall starts w. (Wrapped w)
                               => rigging -> Member primary starts -> w starts Request
                               -> Choreo ps m Response  }

data Request = Put String String  | Get String  | Stop  deriving (Eq, Ord, Read, Show)

data Response = Found String  | NotFound  | Stopped  | Desynchronization [Response]
                deriving (Eq, Ord, Read, Show)

-- | PUT returns the old stored value; GET returns whatever was stored.
handleRequest :: (MonadIO m) => IORef State -> Request -> m Response
handleRequest stateRef (Put key value) = mlookup key <$> modifyIORef stateRef (Map.insert key value)
handleRequest stateRef (Get key) = mlookup key <$> readIORef stateRef
handleRequest _         Stop = return Stopped

mlookup :: String -> State -> Response
mlookup key = maybe NotFound Found . Map.lookup key

type State = Map String String
\end{minted}
\caption{A system for building key-value-store choreographies,
         including an example backup strategy that's polymorphic on the number of backup servers.}
\label{fig:kvs}
%\Description{Forty-nine lines of haskell code defining functions "kvs", "naryReplicationStrategy", "handleRequest", and "mlookup", and associated data types.}
\end{mdframed}
\end{figure*}

During the job interview with Well Typed, they discussed some alternatives to the proof-witness pattern that can probably work.
I haven't played with it enough to say if it would be \emph{better},
but I should make sure to understand what they're doing well enough to express an opinion about it here.

\section{Census Polymorphism}
\label{sec:census-poly}

TODO: This is copy-pasted directly from the enclaves paper; it must be edited/rewritten for this context.

So far, the example choreographies we have discussed have had fixed numbers of participants.
In all prior CP systems this has been a syntactic constraint:
even systems that allow polymorphism over the identities of participants require the participants' "roles" to be explicitly defined in-context.
This is a serious limitation for writing choreographic software;
modern concurrent systems often use dozens to thousands of participants
and are defined parametrically over their number of participants~\cite{bigConcurrent1, corrigan2017prio, bigConcurrent3, bigConcurrent4, dprio2023}.
We assert that such parametric protocol declarations are a required feature for CP to find mainstream use;
our systems provide it in the form of \emph{census polymorphism}.

By "census polymorphism", we mean that a choreographic expression is polymorphic over its census type-variable,
including not just the specific identities listed but also the quantity.\footnote{
    In principle, one can split hairs between census polymorphism and similar polymorphism over other sets of parties, \eg ownership sets.
    We have not found such distinctions to be useful for describing system capabilities,
    but they can be relevant when talking about the type of a given expression.
}
Naïvely, this is trivial; any \MultiChor expression can easily be written with a type variable as its census
and the relevant parties (whose exact identities can also be polymorphic) can be guaranteed to be present by taking
membership proofs as arguments.
However, this approach has a limitation: Since the number of type variables of a choreography must be fixed
and there is no way to \emph{explicitly list} an arbitrary number of parties,
there may be parties not identified by such arguments.
They'll receive any broadcasts and participate in any active replication that applies to the whole census,
but there's no way to specify them as the senders of messages, nor is there any way to specify that they should receive a message
except by sending it to the whole census.
For this reason, when we speak of "census polymorphism",
we mean \emph{useful} polymorphism that lets an unspecified quantity of parties actively participate in the choreography.
For example one might wish to write a \inlinecode{gather} operation
in which a polymorphic list of participants each send a computed value to a common recipient who aggregates them.
Figure~\ref{fig:census-poly-example} shows an example \MultiChor choreography for a key-value store with a polymorphic list of backup servers.
In Appendix~\ref{sec:mpc} we implement the GMW protocol~\cite{goldreich2019play}, a foundational protocol in multi-party cryptography.
In earlier CP systems it would be necessary to hard-code the number of participants when writing such choreographies.
In this section we show how our libraries overcome the above limitation and represent census-polymorphic choreographies.

\begin{figure*}[tbhp]
  \begin{mdframed}
    \inputminted[xleftmargin=10pt,linenos,fontsize=\scriptsize]{haskell}{figures/kvs_poly.hs.txt}
    \caption{
        A key-value store choreography with an unspecified number of backup servers.
        The main action happens in \inlinecode{handleRequest},
        a choreography involving only the servers which is called via \inlinecode{enclave} on line 21.
        \inlinecode{handleRequest}'s census explicitly includes the primary server, but is polymorphic over the list of backup servers.
        The primary server broadcasts the request (line~5--12); the backups will update their state and report their health
        only for a \inlinecode{Put} request.
        On line 7 the backups call the local IO function \inlinecode{handlePut} in \inlinecode{parallel} using their individual state references;
        \inlinecode{oks} is therefore a \inlinecode{Faceted backups '[] Response}.
        (The extra \inlinecode{'[]} denotes that no party yet knows all of the \inlinecode{oks}.)
        \inlinecode{gather} (line 8) communicates all the \inlinecode{oks} to the primary server
        where they're stored as a \inlinecode{Quire backups Response}.
        If all the backups are ok, then the primary server also handles the request (line 10).
    }
    \label{fig:census-poly-example}
    %\Description{23 lines of Haskell code using MultiChor defining a new version of "kvs" that is parametric over the number of backup servers.}
  \end{mdframed}
\end{figure*}

The first thing that is necessary is a way to loop over a polymorphic list of parties.
The second thing is the ability to express and use divergent data known by un-enumerated parties.
We call such data structures \emph{faceted values}\footnote{
    The word "faceted" is most commonly used in reference to a cut gemstone,
    but analogy to the facets of polyhedral playing dice might be more on-the-nose.
};
they're basically the same as the faceted values introduced in \cite{austin2012},
except their public facet is always "$\bot$" and multiple parties have distinct private facets.
Conceptually, a faceted value is similar to an MLV
(it projects to an owner as a simple value and to a non-owner as a placeholder),
but different owners of a faceted value will have different values for it.
To see the need for faceted values, consider how one would write a census-polymorphic \inlinecode{gather} operation
using only an appropriately-specialized \inlinecode{for}-loop:
Each sender would need to generate its value to send \emph{inside} the loop body,
and the only way for the sent values to be distinct would be by using private local state accessed by \inlinecode{locally}.
This would hardly be satisfying, and the dual case of \inlinecode{scatter} would be even worse:
Any use to which the received values were to be put would also have to fit inside the body of the \inlinecode{for}-loop.
(One couldn't simply append the \inlinecode{scatter}ed values to a list in a typed language
because \inlinecode{Located} values with different owners have different types.)
Our implementations provide these needed features in different ways as discussed in \Cref{sec:census-poly-haskell,sec:census-poly-rust}.

In all three of our implementations, census polymorphism can be resolved statically,
\ie, while one can write choreographies and choreographic functions that are census-polymorphic,
it is always possible in principal to unroll the top-level choreography
(that actually gets compiled)
into a monomorphic form.
(Therefore, we do not bother with a separate proof of the soundness of census polymorphism.)
In \MultiChor, this is denoted by \inlinecode{KnownSymbols} constraints in some type signatures.
We leave any clarity about the prospects of \emph{dynamic} census polymorphism for future work.


\subsection{Census Polymorphism in \MultiChor}
\label{sec:census-poly-haskell}

We leverage the type system of modern Haskell to achieve useful census polymorphism in \MultiChor.
This behavior is implemented as a layer \textit{on top of} \MultiChor's central monad and data-types;
from a theory perspective \MultiChor gets census polymorphism "for free" because it's a Haskell library.
The \MultiChor repository contains over a dozen example choreographies, several of which use census polymorphism.
In Figure~\ref{fig:census-poly-example} we showcase a key-value store choreography that's polymorphic over the number of backup servers.
\Cref{sec:mpc} presents a more involved census-polymorphic example.

Key to \MultiChor's strategy is Haskell's ability to express quantified type variables.
For example, a \inlinecode{Faceted} value is (underneath a little boiler-plate) a function.
Its argument is a \inlinecode{Member} proof that some party is in the list of owners,
and it returns a \inlinecode{Located} value known to the party in question.
Notably, nothing about the type, \inlinecode{Faceted ps cmn x}, indicates who the (type-level!) party indicated by the argument might be.
(The second type parameter, \inlinecode{cmn}, represents parties who know \emph{all} the contained values;
it's frequently \inlinecode{'[]}.)

\inlinecode{Faceted ps cmn x} is actually a special case of a more general type,
\inlinecode{PIndexed ps f}, where \inlinecode{f} can be any \emph{type-level function} from a party to a concrete type.
A \inlinecode{PIndexed} is effectively a type-indexed vector,
except that the type of the value retrieved depends on the index\footnote{
    The case where it does not depend on the index, \ie when \inlinecode{f} is \inlinecode{Const},
    is sufficiently useful in its own right that we package it as the type \inlinecode{Quire}.
    "Quire" is pronounced "choir"; it rhymes with "buyer" and means "a stack of sheets of paper, all cut to the same size".
    Each individual piece of paper is a "leaf".
}.
Because of its unusual \inlinecode{kind}, type classes that one would expect to apply to vectors generally do not apply to \inlinecode{PIndexed}.
What's actually needed for census polymorphism is the ability to \inlinecode{sequence} a \inlinecode{PIndexed} of choreographies.
Since \inlinecode{PIndexed} is not an instance of \inlinecode{Traversable},
we implement the needed function \inlinecode{sequenceP}, which is effectively just a \inlinecode{for}-loop
(in any monad) over type-level lists of parties.
These loops are not unrolled at compile time;
the type class \inlinecode{KnownSymbols} affords to the runtime environment sufficient knowledge of the type-level list.

\begin{figure*}[tbhp]
  \begin{mdframed}
    \inputminted[xleftmargin=10pt,linenos,fontsize=\scriptsize]{haskell}{figures/census-poly-haskell.hs.txt}
    \caption{
        Type signatures for \inlinecode{sequenceP}, \inlinecode{fanOut}, and \inlinecode{scatter}.
    }
    \label{fig:census-poly-haskell}
    %\Description{Fourteen lines of Haskell code using the MulitChor library.}
  \end{mdframed}
\end{figure*}

We could write a satisfactory \inlinecode{scatter} and \inlinecode{gather} directly using \inlinecode{sequenceP},
but we find that by defining the intermediary functions \inlinecode{fanOut} and \inlinecode{fanIn}
we can avoid almost all situations where a programmer might need to use \inlinecode{sequenceP} directly in a choreography.
\inlinecode{fanOut}'s argument is a choreography that results in a \inlinecode{Located} value at the party identified by the loop variable;
it aggregates these results as a \inlinecode{Faceted}.
\inlinecode{fanIn} is almost the same, except that the locations of the resulting values do not vary,
and they are aggregated in a \inlinecode{Quire} located at some list of recipients.
\Cref{fig:census-poly-haskell} shows the type signatures for \inlinecode{sequenceP}, \inlinecode{fanOut}, and \inlinecode{scatter}.
Keen readers may notice that the "\inlinecode{cmn}" parties' views of a \inlinecode{Faceted} are effectively just a \inlinecode{Quire},
and so wonder at the need for \inlinecode{fanIn}.
In fact, \inlinecode{fanIn} \emph{is} less often used than \inlinecode{fanOut},
but it's necessary for expressing choreographic loops that yield values which aren't known to the parties over whom the loop is defined.
For example, the GMW protocol, which we implement using \MultiChor in \Cref{sec:mpc}, cannot be written using only \inlinecode{fanOut}.

Modern Haskell language features, especially type-variable quantification,
enable \MultiChor's implementation of census polymorphism to be entirely type-safe and transparent to users.
This is a flexible system within which users can easily write their own novel and bespoke functions and data structures;
we will show in the following section that such flexibility is not entirely necessary for census polymorphism.


\section{Future Work}
\label{sec:future-implementation}
It is natural to ask why \MultiChor has a "core" API distinct from the ergonomic API afforded to end-users.
This design pattern makes reasoning about \MultiChor's implementation easier;
whether there are any performance implications has not been explored\footnote{
  The need for methods for comparing the performance of CP systems was acknowleged by the community
  of CP researchers attending PLDI24.
}.
In the coming months, we would like to push the simplicity of the core API even further:
\begin{enumerate}
  \item The use of a freer monad system is not actually necessary.
        It facilitates implementation, but it's also an additional "moving part" that can be removed
        without affecting the system's behavior.
  \item As mentioned earlier \todo{link}, the functions \inlinecode{flatten} and \inlinecode{othersForget}
        could be removed from the core API and replaced with derived monadic functions.
        This would be a step backwards for the ergonomics of \MultiChor,
        so we do not advocate making such a change to the version published on Hackage.
  \item Replacing the core operation \inlinecode{congruently'} with \inlinecode{naked}
        (a monadic operator that unwraps an MLV known to the entire census)
        may degrade ergonomics.
        On the other hand, it would allow simplification of \inlinecode{locally'}
        by obviating the \inlinecode{Unwrap} argument;
        \ie \inlinecode{locally'}'s argument would no longer be a function at all!
  \item Having made the above changes, the only remaining place where \inlinecode{Located} values would get unwrapped
        would be \inlinecode{naked}.
        We would be able to remove the underlying \inlinecode{Choreo} constructor for \inlinecode{naked}
        and change the implementation of \inlinecode{Located} to be a \inlinecode{newtype} wrapper for
        a census-polymorphic choreography yielding the target value.
        In other words, \inlinecode{naked} would be the field accessor function for \inlinecode{Located}.
\end{enumerate}

We have already demonstrated the viability of the above changes in a reduced "scratch" environment.
By finishing that work (porting them back to a fork of \MultiChor and showing that no expressivity is lost),
we will facilitate subsequent theoretical work on CP, which would benefit from a formal model more closely aligned with
\MultiChor's API than \HLSCentral is.

\bibliographystyle{chicago}
\bibliography{refs}
